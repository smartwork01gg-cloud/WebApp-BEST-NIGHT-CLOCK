<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Reader Pro - Fix Navigazione</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/page-flip@2.0.7/dist/js/page-flip.browser.min.js"></script>

    <style>
        :root { --accent: #e67e22; --bg: #f5f5f5; --panel: #ffffff; --text: #333; --page-bg: #ffffff; --page-text: #333; }
        body.night-mode { --bg: #121212; --panel: #1e1e1e; --text: #e0e0e0; --page-bg: #2c2c2c; --page-text: #f0f0f0; }
        
        body { font-family: system-ui, sans-serif; background: var(--bg); margin: 0; height: 100vh; color: var(--text); overflow: hidden; display: flex; flex-direction: column; }
        
        #library-overlay { position: fixed; inset: 0; background: var(--bg); z-index: 1000; overflow-y: auto; padding: 20px; }
        .book-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 20px; max-width: 1200px; margin: 20px auto; }
        .book-card { background: var(--panel); border-radius: 12px; overflow: hidden; position: relative; cursor: pointer; border: 1px solid #444; }
        .book-cover { width: 100%; height: 200px; object-fit: cover; background: #222; display: block; }
        .del-btn { position: absolute; top: 5px; right: 5px; background: #c0392b; color: white; border: none; border-radius: 50%; width: 25px; height: 25px; cursor: pointer; z-index: 10; }

        .toolbar { background: var(--panel); padding: 10px; display: flex; align-items: center; justify-content: space-between; border-bottom: 2px solid var(--accent); z-index: 10; }
        .btn { background: var(--accent); color: white; border: none; padding: 8px 15px; border-radius: 8px; cursor: pointer; font-weight: bold; }
        .viewport { flex: 1; display: flex; justify-content: center; align-items: center; background: #000; position: relative; overflow: hidden; }
        
        /* Contenitore gestito dinamicamente */
        #book-wrapper { position: relative; width: 500px; height: 700px; transform-origin: center center; display: none; margin: auto; }
        .page { background: var(--page-bg) !important; width: 100%; height: 100%; overflow: hidden; }
        .page-content { padding: 45px; color: var(--page-text) !important; line-height: 1.6; font-family: 'Georgia', serif; height: 100%; box-sizing: border-box; font-size: 18px; }
        .page-content img { max-width: 100% !important; max-height: 80% !important; object-fit: contain; display: block; margin: 10px auto; }

        body.night-mode .pdf-page-img { filter: invert(0.9) hue-rotate(180deg) brightness(0.8); }
        .nav-bar { background: var(--panel); padding: 10px 20px; border-top: 1px solid #333; }
        input[type="range"] { width: 100%; accent-color: var(--accent); }

        #paginator-tester { position: absolute; visibility: hidden; width: 410px; padding: 45px; line-height: 1.6; font-family: 'Georgia', serif; pointer-events: none; top: 0; }
    </style>
</head>
<body>

<div id="paginator-tester"></div>

<div id="library-overlay">
    <header style="display:flex; justify-content:space-between; align-items:center; max-width:1200px; margin:0 auto">
        <h2>üìö La Mia Libreria</h2>
        <label class="btn">‚ûï CARICA LIBRO <input type="file" id="file-input" hidden accept=".pdf,.epub"></label>
    </header>
    <div id="book-grid" class="book-grid"></div>
</div>

<div class="toolbar">
    <button class="btn" onclick="showLibrary()">üè† Home</button>
    <button class="btn" id="theme-btn" onclick="toggleTheme()" style="background:#34495e">üåô Notte</button>    
    <div id="status" style="font-size:12px; color:var(--accent)">Pronto</div>
    <div style="display:flex; gap:10px">
        <select id="voice-select" class="btn" style="background:#333"></select>
        <button id="tts-btn" class="btn" onclick="toggleTTS()">üîä Leggi</button>
        <select id="speed-select" class="btn" style="background:#333; width: 70px;">
            <option value="1" selected>1x</option>
            <option value="1.5">1.5x</option>
        </select>
    </div>
</div>

<div class="viewport" id="viewport-main">
    <div id="book-wrapper">
        </div>
</div>

<div class="nav-bar">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px">
        <span style="font-size:13px">Pagina: <span id="current-page">0</span> / <span id="total-pages">0</span></span>
    </div>
    <input type="range" id="page-slider" min="0" value="0">
</div>

<script>
    let pageFlip = null;
    let currentBook = null;
    let currentFontSize = 18;
    let isReading = false;
    const synth = window.speechSynthesis;

    const NO_COVER = "data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='150' height='200' viewBox='0 0 150 200'%3E%3Crect width='150' height='200' fill='%23333'/%3E%3Ctext x='50%25' y='50%25' fill='%23ccc' font-family='sans-serif' font-size='14' text-anchor='middle' dy='.3em'%3ELIBRO%3C/text%3E%3C/svg%3E";

    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    const dbName = "ReaderV11_NavFix";
    const initDB = () => new Promise(res => {
        const req = indexedDB.open(dbName, 1);
        req.onupgradeneeded = e => e.target.result.createObjectStore("books", { keyPath: "id" });
        req.onsuccess = e => res(e.target.result);
    });

    function fastPaginate(htmlContent) {
        const tester = document.getElementById('paginator-tester');
        tester.style.fontSize = currentFontSize + 'px';
        const maxHeight = 610; 
        const container = document.createElement('div');
        container.innerHTML = htmlContent;
        const pages = [];
        let currentPageContent = "";

        const addNode = (node) => {
            const tempHtml = node.nodeType === 3 ? node.textContent : node.outerHTML;
            tester.innerHTML = currentPageContent + tempHtml;

            if (tester.offsetHeight > maxHeight) {
                if (node.nodeType === 1 && node.childNodes.length > 1) {
                    Array.from(node.childNodes).forEach(child => addNode(child));
                } else if (node.nodeType === 3) {
                    const words = node.textContent.split(' ');
                    words.forEach(word => {
                        tester.innerHTML = currentPageContent + word + " ";
                        if (tester.offsetHeight > maxHeight) {
                            pages.push(currentPageContent);
                            currentPageContent = word + " ";
                        } else {
                            currentPageContent += word + " ";
                        }
                    });
                } else {
                    pages.push(currentPageContent);
                    currentPageContent = tempHtml;
                }
            } else {
                currentPageContent += tempHtml;
            }
        };

        Array.from(container.childNodes).forEach(node => addNode(node));
        if (currentPageContent.trim()) pages.push(currentPageContent);
        return pages.filter(p => p.trim().length > 0);
    }

    async function processFile(file) {
        const status = document.getElementById('status');
        const ext = file.name.split('.').pop().toLowerCase();
        let bookData = { id: file.name, type: ext, pages: [], text: [], cover: "", bookmark: 0 };
        status.innerText = "Salvataggio...";

        try {
            const arrayBuffer = await file.arrayBuffer();
            if (ext === 'pdf') {
                const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                for (let i = 1; i <= Math.min(pdf.numPages, 500); i++) {
                    const page = await pdf.getPage(i);
                    const vp = page.getViewport({ scale: 1.2 });
                    const canvas = document.createElement('canvas');
                    canvas.width = vp.width; canvas.height = vp.height;
                    await page.render({ canvasContext: canvas.getContext('2d'), viewport: vp }).promise;
                    const b64 = canvas.toDataURL('image/webp', 0.6);
                    bookData.pages.push(b64);
                    if(i===1) bookData.cover = b64;
                    const txt = await page.getTextContent();
                    bookData.text.push(txt.items.map(s => s.str).join(' '));
                }
            } else if (ext === 'epub') {
                const zip = await JSZip.loadAsync(arrayBuffer);
                const imgMap = new Map();
                for (let name in zip.files) {
                    if (/\.(jpg|jpeg|png|gif|webp|svg)$/i.test(name)) {
                        const b64 = await zip.files[name].async("base64");
                        const fExt = name.split('.').pop().toLowerCase();
                        imgMap.set(name.split('/').pop(), `data:image/${fExt === 'svg' ? 'svg+xml' : 'jpeg'};base64,${b64}`);
                    }
                }
                const book = ePub(arrayBuffer);
                await book.opened;
                const spine = await book.loaded.spine;
                
                try {
                    const cUrl = await book.coverUrl();
                    if (cUrl) {
                        const res = await fetch(cUrl);
                        const blob = await res.blob();
                        bookData.cover = await new Promise(r => { 
                            const reader = new FileReader(); reader.onloadend = () => r(reader.result); reader.readAsDataURL(blob); 
                        });
                    }
                } catch(e) { bookData.cover = NO_COVER; }

                for (const section of spine.spineItems) {
                    await section.load(book.load.bind(book));
                    const doc = section.document;
                    doc.querySelectorAll('img').forEach(i => {
                        const src = i.getAttribute('src').split('/').pop();
                        if(imgMap.has(src)) i.src = imgMap.get(src);
                    });
                    const pgs = fastPaginate(doc.body.innerHTML);
                    pgs.forEach(p => {
                        bookData.pages.push(p);
                        const t = document.createElement('div'); t.innerHTML = p;
                        bookData.text.push(t.innerText);
                    });
                    section.unload();
                }
            }
            const db = await initDB();
            await db.transaction("books", "readwrite").objectStore("books").put(bookData);
            status.innerText = "Libro aggiunto!";
            updateLibraryUI();
            loadBook(file.name);
        } catch (e) { status.innerText = "Errore!"; console.error(e); }
    }

    async function loadBook(id) {
        const db = await initDB();
        const req = db.transaction("books").objectStore("books").get(id);
        req.onsuccess = () => {
            currentBook = req.result;
            if(!currentBook) return;
            
            // 1. Reset Interfaccia
            document.getElementById('library-overlay').style.display = 'none';
            const wrapper = document.getElementById('book-wrapper');
            
            // 2. Distruzione istanza precedente
            if (pageFlip) {
                try { pageFlip.destroy(); } catch(e) {}
                pageFlip = null;
            }

            // 3. RICREAZIONE TOTALE DEL CONTENITORE (Cruciale per il rientro)
            wrapper.innerHTML = '<div id="book-container"></div>';
            const container = document.getElementById('book-container');
            wrapper.style.display = 'block';

            // 4. Inserimento Pagine
            currentBook.pages.forEach(p => {
                const div = document.createElement('div');
                div.className = 'page';
                div.innerHTML = currentBook.type === 'pdf' ? 
                    `<img src="${p}" class="pdf-page-img" style="width:100%;height:100%;object-fit:contain">` : 
                    `<div class="page-content">${p}</div>`;
                container.appendChild(div);
            });

            resize();
            // Piccolo delay extra per garantire il rendering del DOM
            setTimeout(initFlip, 300);
        };
    }

    function initFlip() {
        const container = document.getElementById('book-container');
        if (!container || container.children.length === 0) return;

        pageFlip = new St.PageFlip(container, {
            width: 500, height: 700, showCover: false, usePortrait: true, mobileScrollSupport: true
        });

        pageFlip.loadFromHTML(container.querySelectorAll('.page'));
        
        document.getElementById('total-pages').innerText = pageFlip.getPageCount();
        document.getElementById('page-slider').max = Math.max(0, pageFlip.getPageCount() - 1);
        
        pageFlip.on('flip', (e) => {
            document.getElementById('current-page').innerText = e.data + 1;
            document.getElementById('page-slider').value = e.data;
            saveBookmark(e.data);
            if(isReading) setTimeout(startReadingCurrentPage, 400);
        });

        if(currentBook.bookmark) {
            pageFlip.turnToPage(currentBook.bookmark);
            document.getElementById('current-page').innerText = currentBook.bookmark + 1;
        } else {
            document.getElementById('current-page').innerText = 1;
        }
    }

    function showLibrary() {
        if(synth) synth.cancel(); 
        isReading = false;
        
        if (pageFlip) {
            try { pageFlip.destroy(); } catch(e) {}
            pageFlip = null;
        }

        document.getElementById('book-wrapper').style.display = 'none';
        document.getElementById('library-overlay').style.display = 'block';
        updateLibraryUI();
    }

    async function updateLibraryUI() {
        const db = await initDB();
        const req = db.transaction("books").objectStore("books").getAll();
        req.onsuccess = () => {
            const grid = document.getElementById('book-grid');
            grid.innerHTML = req.result.map(b => `
                <div class="book-card" onclick="loadBook('${b.id.replace(/'/g, "\\'")}')">
                    <button class="del-btn" onclick="event.stopPropagation(); deleteBook('${b.id.replace(/'/g, "\\'")}')">√ó</button>
                    <img src="${b.cover || NO_COVER}" class="book-cover" onerror="this.src='${NO_COVER}'">
                    <div style="padding:10px; font-size:11px; font-weight:bold; color:var(--text); text-align:center">${b.id}</div>
                </div>
            `).join('');
        };
    }

    async function deleteBook(id) {
        if(!confirm("Eliminare?")) return;
        const db = await initDB();
        db.transaction("books", "readwrite").objectStore("books").delete(id);
        updateLibraryUI();
    }

    async function saveBookmark(idx) {
        if(!currentBook) return;
        const db = await initDB();
        currentBook.bookmark = idx;
        db.transaction("books", "readwrite").objectStore("books").put(currentBook);
    }

    function resize() {
        const wrap = document.getElementById('book-wrapper');
        const vp = document.getElementById('viewport-main');
        if (!wrap || !vp) return;
        const scale = Math.min((vp.clientWidth - 20) / 500, (vp.clientHeight - 20) / 700);
        wrap.style.transform = `scale(${scale})`;
    }

    function toggleTheme() {
        const isNight = document.body.classList.toggle('night-mode');
        document.getElementById('theme-btn').innerText = isNight ? "‚òÄÔ∏è Giorno" : "üåô Notte";
        localStorage.setItem('theme', isNight ? 'night' : 'day');
    }

    function toggleTTS() {
        if (isReading) { synth.cancel(); isReading = false; document.getElementById('tts-btn').innerText = "üîä Leggi"; }
        else { isReading = true; document.getElementById('tts-btn').innerText = "‚èπÔ∏è Stop"; startReadingCurrentPage(); }
    }

    function startReadingCurrentPage() {
        synth.cancel();
        const idx = pageFlip.getCurrentPageIndex();
        const msg = new SpeechSynthesisUtterance(currentBook.text[idx]);
        msg.rate = parseFloat(document.getElementById('speed-select').value);
        msg.onend = () => { if(isReading) pageFlip.flipNext(); };
        const v = synth.getVoices().find(v => v.name === document.getElementById('voice-select').value);
        if(v) msg.voice = v;
        synth.speak(msg);
    }

    window.addEventListener('resize', resize);
    document.getElementById('file-input').addEventListener('change', e => processFile(e.target.files[0]));
    document.getElementById('page-slider').oninput = e => pageFlip?.turnToPage(parseInt(e.target.value));
    
    synth.onvoiceschanged = () => {
        const voices = synth.getVoices().filter(v => v.lang.startsWith('it'));
        document.getElementById('voice-select').innerHTML = voices.map(v => `<option value="${v.name}">${v.name}</option>`).join('');
    };

    window.onload = () => { updateLibraryUI(); if (localStorage.getItem('theme') === 'night') toggleTheme(); };
</script>
</body>
</html>