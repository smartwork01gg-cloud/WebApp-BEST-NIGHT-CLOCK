<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D Reader Pro - PDF TTS Fix</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/epubjs/dist/epub.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/page-flip@2.0.7/dist/js/page-flip.browser.min.js"></script>

    <style>
        :root { --accent: #e67e22; --bg: #f5f5f5; --panel: #ffffff; --text: #333; --page-bg: #ffffff; --page-text: #333; }
        body.night-mode { --bg: #121212; --panel: #1e1e1e; --text: #e0e0e0; --page-bg: #2c2c2c; --page-text: #f0f0f0; }
        
        body { font-family: system-ui, -apple-system, sans-serif; background: var(--bg); margin: 0; height: 100vh; color: var(--text); overflow: hidden; display: flex; flex-direction: column; }
        
        #library-overlay { position: fixed; inset: 0; background: var(--bg); z-index: 1000; overflow-y: auto; padding: 15px; }
        .book-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 15px; max-width: 1200px; margin: 20px auto; }
        .book-card { background: var(--panel); border-radius: 12px; overflow: hidden; position: relative; cursor: pointer; border: 1px solid rgba(0,0,0,0.1); box-shadow: 0 4px 6px rgba(0,0,0,0.1); }
        .book-cover { width: 100%; height: 170px; object-fit: cover; background: #222; display: block; }
        .del-btn { position: absolute; top: 5px; right: 5px; background: #c0392b; color: white; border: none; border-radius: 50%; width: 28px; height: 28px; cursor: pointer; z-index: 10; font-size: 18px; }

        .toolbar { background: var(--panel); padding: 8px 12px; display: flex; align-items: center; justify-content: space-between; border-bottom: 2px solid var(--accent); z-index: 10; gap: 8px; }
        .tool-group { display: flex; gap: 5px; align-items: center; }
        .btn { background: var(--accent); color: white; border: none; padding: 10px; border-radius: 8px; cursor: pointer; font-weight: bold; display: flex; align-items: center; justify-content: center; min-width: 40px; }
        .btn-sec { background: #34495e; }
        
        #loading-ui { display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: var(--panel); padding: 20px; border-radius: 15px; box-shadow: 0 0 20px rgba(0,0,0,0.3); z-index: 2000; text-align: center; width: 250px; }
        .progress-bar { width: 100%; height: 10px; background: #ddd; border-radius: 5px; margin-top: 10px; overflow: hidden; }
        #progress-fill { width: 0%; height: 100%; background: var(--accent); transition: width 0.3s; }

        .viewport { flex: 1; display: flex; justify-content: center; align-items: center; background: #000; position: relative; overflow: hidden; }
        #book-wrapper { position: relative; width: 500px; height: 700px; transform-origin: center center; display: none; margin: auto; }
        
        .page { background: var(--page-bg) !important; width: 100%; height: 100%; overflow: hidden; display: flex; align-items: center; justify-content: center; }
        .page img { max-width: 100%; max-height: 100%; object-fit: contain; pointer-events: none; }
        
        .page-content { padding: 35px; color: var(--page-text) !important; line-height: 1.6; font-family: 'Georgia', serif; height: 100%; width: 100%; box-sizing: border-box; font-size: 18px; overflow: hidden; }
        .page-content img { max-width: 100% !important; max-height: 70% !important; object-fit: contain !important; display: block; margin: 10px auto; }

        .nav-bar { background: var(--panel); padding: 10px 15px; border-top: 1px solid rgba(0,0,0,0.1); }
        input[type="range"] { width: 100%; accent-color: var(--accent); height: 25px; }

        #paginator-tester { position: absolute; visibility: hidden; width: 410px; padding: 45px; line-height: 1.6; font-family: 'Georgia', serif; pointer-events: none; top: 0; }
    </style>
</head>
<body>

<div id="paginator-tester"></div>

<div id="loading-ui">
    <div id="loading-msg" style="font-weight: bold;">Elaborazione...</div>
    <div class="progress-bar"><div id="progress-fill"></div></div>
    <div id="progress-text" style="font-size: 12px; margin-top: 5px;">0%</div>
</div>

<div id="library-overlay">
    <header style="display:flex; justify-content:space-between; align-items:center; max-width:1200px; margin:0 auto">
        <h2>üìö Libreria</h2>
        <label class="btn">‚ûï <span>CARICA</span> <input type="file" id="file-input" hidden accept=".pdf,.epub"></label>
    </header>
    <div id="book-grid" class="book-grid"></div>
</div>

<div class="toolbar">
    <div class="tool-group"> 
        <button class="btn" onclick="showLibrary()">üè†</button>
        <button class="btn btn-sec" onclick="toggleFullscreen()">üì∫</button>
    </div>

    <div class="tool-group"> 
        <button class="btn btn-sec" id="theme-btn" onclick="toggleTheme()">üåô</button>
        <button class="btn btn-sec" onclick="changeSize(-1)">A-</button>
        <button class="btn btn-sec" onclick="changeSize(1)">A+</button>
    </div>
    
    <div id="status" style="font-size:11px; color:var(--accent);">Pronto</div>
    
    <div class="tool-group"> 
        <select id="voice-select" class="btn btn-sec" style="font-size: 10px; height: 35px; max-width: 120px;"></select>
        <select id="speed-select" class="btn btn-sec" style="font-size: 11px;">
            <option value="1">1x</option>
            <option value="1.2">1.2x</option>
            <option value="1.25">1.25x</option>
            <option value="1.5">1.5x</option>
            <option value="1.6">1.6x</option>
            <option value="1.8">1.8x</option>
            <option value="2">2x</option>
        </select>
        <button id="tts-btn" class="btn" onclick="toggleTTS()">üîä</button>
    </div>
</div>

<div class="viewport" id="viewport-main">
    <div id="book-wrapper"></div>
</div>

<div class="nav-bar">
    <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px">
        <span style="font-size:12px; font-weight:bold">Pag. <span id="current-page">0</span> / <span id="total-pages">0</span></span>
    </div>
    <input type="range" id="page-slider" min="0" value="0">
</div>

<script>
    let pageFlip = null, currentBook = null, currentFontSize = 18, pdfZoom = 1.0, isReading = false;
    let rawHtmlBuffer = "";
    const synth = window.speechSynthesis;
    const NO_COVER = "data:image/svg+xml;charset=UTF-8,%3Csvg xmlns='http://www.w3.org/2000/svg' width='150' height='200' viewBox='0 0 150 200'%3E%3Crect width='150' height='200' fill='%23333'/%3E%3Ctext x='50%25' y='50%25' fill='%23ccc' font-family='sans-serif' font-size='14' text-anchor='middle' dy='.3em'%3ELIBRO%3C/text%3E%3C/svg%3E";

    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.4.120/pdf.worker.min.js';

    const dbName = "ReaderV15_TTS_Fixed";
    const initDB = () => new Promise(res => {
        const req = indexedDB.open(dbName, 1);
        req.onupgradeneeded = e => e.target.result.createObjectStore("books", { keyPath: "id" });
        req.onsuccess = e => res(e.target.result);
    });

    async function toBase64(url) {
        if (!url || url.startsWith('data:')) return url;
        try {
            const response = await fetch(url);
            const blob = await response.blob();
            return new Promise((resolve) => {
                const reader = new FileReader();
                reader.onloadend = () => resolve(reader.result);
                reader.readAsDataURL(blob);
            });
        } catch (e) { return NO_COVER; }
    }

    function updateProgress(p) {
        document.getElementById('loading-ui').style.display = 'block';
        document.getElementById('progress-fill').style.width = p + '%';
        document.getElementById('progress-text').innerText = Math.round(p) + '%';
        if(p >= 100) setTimeout(() => document.getElementById('loading-ui').style.display = 'none', 500);
    }

    function changeSize(dir) {
        if (!currentBook || currentBook.type !== 'epub') return;
        currentFontSize = Math.max(12, currentFontSize + (dir * 2));
        currentBook.pages = fastPaginate(rawHtmlBuffer);
        renderBookContent();
    }

    function fastPaginate(html) {
        const tester = document.getElementById('paginator-tester');
        tester.style.fontSize = currentFontSize + 'px';
        const maxHeight = 610; 
        const container = document.createElement('div');
        container.innerHTML = html;
        const pages = []; let current = "";
        const walk = (node) => {
            const h = node.nodeType === 3 ? node.textContent : node.outerHTML;
            tester.innerHTML = current + h;
            if (tester.offsetHeight > maxHeight) {
                if (node.nodeType === 1 && node.childNodes.length > 1) {
                    Array.from(node.childNodes).forEach(walk);
                } else { pages.push(current); current = h; }
            } else { current += h; }
        };
        Array.from(container.childNodes).forEach(walk);
        if (current) pages.push(current);
        return pages.filter(p => p.trim().length > 0);
    }

    async function processFile(file) {
        updateProgress(5);
        const ext = file.name.split('.').pop().toLowerCase();
        let bookData = { id: file.name, type: ext, pages: [], text: [], cover: "", bookmark: 0, rawHtml: "" };
        
        try {
            const arrayBuffer = await file.arrayBuffer();
            if (ext === 'pdf') {
                const pdf = await pdfjsLib.getDocument({data: arrayBuffer}).promise;
                for (let i = 1; i <= pdf.numPages; i++) {
                    const page = await pdf.getPage(i);
                    const unscaledVP = page.getViewport({ scale: 1 });
                    const scale = Math.min(500 / unscaledVP.width, 700 / unscaledVP.height);
                    const vp = page.getViewport({ scale: scale * 2 });
                    
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = vp.width; canvas.height = vp.height;
                    await page.render({ canvasContext: ctx, viewport: vp }).promise;
                    
                    bookData.pages.push(canvas.toDataURL('image/webp', 0.6));
                    if(i === 1) bookData.cover = bookData.pages[0];

                    // FIX ESTRAZIONE TESTO PDF
                    const textContent = await page.getTextContent();
                    const pageText = textContent.items.map(it => it.str).join(" ");
                    bookData.text.push(pageText);

                    updateProgress(5 + (i / pdf.numPages * 95));
                }
            } else if (ext === 'epub') {
                const zip = await JSZip.loadAsync(arrayBuffer);
                const imgMap = new Map();
                for (let name of Object.keys(zip.files)) {
                    if (/\.(jpg|jpeg|png|gif|webp|svg)$/i.test(name)) {
                        const b64 = await zip.files[name].async("base64");
                        imgMap.set(name.split('/').pop(), `data:image/jpeg;base64,${b64}`);
                    }
                }
                const book = ePub(arrayBuffer);
                await book.opened;
                bookData.cover = await toBase64(await book.coverUrl());
                const spine = await book.loaded.spine;
                let fullHtml = "";
                for (let i=0; i<spine.spineItems.length; i++) {
                    const section = spine.spineItems[i];
                    await section.load(book.load.bind(book));
                    const doc = section.document;
                    doc.querySelectorAll('img').forEach(img => {
                        const src = img.getAttribute('src').split('/').pop();
                        if(imgMap.has(src)) img.src = imgMap.get(src);
                    });
                    fullHtml += doc.body.innerHTML;
                    section.unload();
                }
                bookData.rawHtml = fullHtml;
                bookData.pages = fastPaginate(fullHtml);
                updateProgress(100);
            }
            
            const db = await initDB();
            await db.transaction("books", "readwrite").objectStore("books").put(bookData);
            updateLibraryUI();
            loadBook(file.name);
        } catch (e) { alert("Errore caricamento!"); updateProgress(0); }
    }

    async function loadBook(id) {
        const db = await initDB();
        const req = db.transaction("books").objectStore("books").get(id);
        req.onsuccess = () => {
            currentBook = req.result;
            rawHtmlBuffer = currentBook.rawHtml || "";
            renderBookContent();
        };
    }

    function renderBookContent() {
        document.getElementById('library-overlay').style.display = 'none';
        const wrapper = document.getElementById('book-wrapper');
        if (pageFlip) { try { pageFlip.destroy(); } catch(e) {} }
        wrapper.innerHTML = '<div id="book-container"></div>';
        const container = document.getElementById('book-container');
        wrapper.style.display = 'block';
        
        currentBook.pages.forEach(p => {
            const div = document.createElement('div');
            div.className = 'page';
            div.innerHTML = currentBook.type === 'pdf' ? 
                `<img src="${p}">` : 
                `<div class="page-content" style="font-size:${currentFontSize}px">${p}</div>`;
            container.appendChild(div);
        });
        resize();
        setTimeout(() => {
            pageFlip = new St.PageFlip(container, { width: 500, height: 700, showCover: false, usePortrait: true, mobileScrollSupport: true });
            pageFlip.loadFromHTML(container.querySelectorAll('.page'));
            document.getElementById('total-pages').innerText = pageFlip.getPageCount();
            document.getElementById('page-slider').max = pageFlip.getPageCount() - 1;
            
            pageFlip.on('flip', (e) => {
                document.getElementById('current-page').innerText = e.data + 1;
                document.getElementById('page-slider').value = e.data;
                saveBookmark(e.data);
                // Se la lettura √® attiva, riparte sulla nuova pagina dopo il voltare della pagina
                if(isReading) {
                    synth.cancel();
                    setTimeout(startReading, 600);
                }
            });
            if(currentBook.bookmark) pageFlip.turnToPage(currentBook.bookmark);
        }, 300);
    }

    function resize() {
        const wrap = document.getElementById('book-wrapper');
        const vp = document.getElementById('viewport-main');
        if (!wrap || !vp) return;
        const scale = Math.min((vp.clientWidth - 15) / 500, (vp.clientHeight - 15) / 700);
        wrap.style.transform = `scale(${scale * pdfZoom})`;
    }

    async function updateLibraryUI() {
        const db = await initDB();
        const req = db.transaction("books").objectStore("books").getAll();
        req.onsuccess = () => {
            document.getElementById('book-grid').innerHTML = req.result.map(b => `
                <div class="book-card" onclick="loadBook('${b.id.replace(/'/g, "\\'")}')">
                    <button class="del-btn" onclick="event.stopPropagation(); deleteBook('${b.id.replace(/'/g, "\\'")}')">√ó</button>
                    <img src="${b.cover || NO_COVER}" class="book-cover">
                    <div style="padding:8px; font-size:10px; font-weight:bold; text-align:center">${b.id}</div>
                </div>
            `).join('');
        };
    }

    function toggleTheme() {
        const isNight = document.body.classList.toggle('night-mode');
        const btn = document.getElementById('theme-btn');
        if(btn) btn.innerText = isNight ? "‚òÄÔ∏è" : "üåô";
        localStorage.setItem('theme', isNight ? 'night' : 'day');
    }

    function toggleTTS() {
        if (isReading) { 
            synth.cancel(); 
            isReading = false; 
            document.getElementById('tts-btn').innerText = "üîä";
        } else { 
            isReading = true; 
            document.getElementById('tts-btn').innerText = "‚èπÔ∏è";
            startReading(); 
        }
    }

    function startReading() {
        if (!isReading || !currentBook) return;
        synth.cancel();

        const idx = pageFlip.getCurrentPageIndex();
        let text = "";

        // RECUPERO TESTO SPECIFICO PER TIPO FILE
        if (currentBook.type === 'pdf') {
            text = (currentBook.text && currentBook.text[idx]) ? currentBook.text[idx] : "";
        } else {
            const pages = document.querySelectorAll('.page-content');
            text = pages[idx] ? pages[idx].innerText : "";
        }

        if (!text || text.trim().length < 2) {
            // Se la pagina √® vuota (es. solo immagine), passa alla prossima
            if (idx < pageFlip.getPageCount() - 1) {
                pageFlip.flipNext();
            } else {
                isReading = false;
                document.getElementById('tts-btn').innerText = "üîä";
            }
            return;
        }

        const msg = new SpeechSynthesisUtterance(text);
        
        // Impostazione Voce
        const voices = synth.getVoices();
        const selectedVoiceName = document.getElementById('voice-select').value;
        const voice = voices.find(v => v.name === selectedVoiceName);
        if (voice) msg.voice = voice;
        
        // Impostazione Velocit√†
        msg.rate = parseFloat(document.getElementById('speed-select').value);
        
        msg.onend = () => {
            if (isReading) {
                if (idx < pageFlip.getPageCount() - 1) {
                    pageFlip.flipNext(); // Questo attiver√† l'evento 'flip' che richiama startReading
                } else {
                    isReading = false;
                    document.getElementById('tts-btn').innerText = "üîä";
                }
            }
        };

        msg.onerror = () => { isReading = false; document.getElementById('tts-btn').innerText = "üîä"; };
        
        synth.speak(msg);
    }

    function showLibrary() { 
        synth.cancel(); isReading = false;
        document.getElementById('tts-btn').innerText = "üîä";
        document.getElementById('book-wrapper').style.display='none'; 
        document.getElementById('library-overlay').style.display='block'; 
        updateLibraryUI();
    }
    
    function toggleFullscreen() { if (!document.fullscreenElement) document.documentElement.requestFullscreen(); else document.exitFullscreen(); }
    async function deleteBook(id) { if(confirm("Elimina?")) { const db = await initDB(); db.transaction("books", "readwrite").objectStore("books").delete(id); updateLibraryUI(); } }
    async function saveBookmark(idx) { if(!currentBook) return; const db = await initDB(); currentBook.bookmark = idx; db.transaction("books", "readwrite").objectStore("books").put(currentBook); }

    window.addEventListener('resize', resize);
    document.getElementById('file-input').onchange = e => processFile(e.target.files[0]);
    document.getElementById('page-slider').oninput = e => pageFlip?.turnToPage(parseInt(e.target.value));

    function loadVoices() {
        const voices = synth.getVoices();
        const voiceSelect = document.getElementById('voice-select');
        // Filtra per voci italiane o inglesi come fallback
        const filtered = voices.filter(v => v.lang.startsWith('it') || v.lang.startsWith('en'));
        voiceSelect.innerHTML = filtered
            .map(v => `<option value="${v.name}">${v.name.substring(0,18)}</option>`)
            .join('');
    }

    if (speechSynthesis.onvoiceschanged !== undefined) {
        speechSynthesis.onvoiceschanged = loadVoices;
    }

    window.onload = () => { 
        updateLibraryUI(); 
        loadVoices();
        if (localStorage.getItem('theme') === 'night') toggleTheme(); 
    };
</script>
</body>
</html>