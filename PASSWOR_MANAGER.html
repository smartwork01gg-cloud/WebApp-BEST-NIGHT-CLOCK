<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KeePass Password Manager</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .login-screen {
            display: flex;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            padding: 20px;
        }

        .login-container {
            background: white;
            padding: 40px;
            border-radius: 15px;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
            max-width: 500px;
            width: 100%;
        }

        .login-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .login-header h1 {
            color: #1e3c72;
            font-size: 2em;
            margin-bottom: 10px;
        }

        .login-header .icon {
            font-size: 4em;
            margin-bottom: 15px;
        }

        .main-container {
            display: none;
            height: 100vh;
            flex-direction: column;
        }

        .header {
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 20px;
            flex: 1;
        }

        .vault-name {
            font-size: 1.2em;
            font-weight: 600;
        }

        .header-actions {
            display: flex;
            gap: 8px;
        }

        .icon-btn {
            background: rgba(255,255,255,0.2);
            border: none;
            color: white;
            width: 36px;
            height: 36px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .icon-btn:hover {
            background: rgba(255,255,255,0.3);
            transform: scale(1.05);
        }

        .toolbar {
            background: white;
            padding: 12px 20px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }

        .content-area {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 280px;
            background: #f8f9fa;
            border-right: 1px solid #dee2e6;
            overflow-y: auto;
            padding: 15px;
        }

        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
            background: white;
        }

        .form-group {
            margin-bottom: 20px;
        }

        label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 600;
        }

        input[type="text"],
        input[type="password"],
        input[type="url"],
        input[type="file"],
        textarea,
        select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input:focus,
        textarea:focus,
        select:focus {
            outline: none;
            border-color: #1e3c72;
        }

        textarea {
            resize: vertical;
            min-height: 100px;
        }

        button {
            padding: 10px 18px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #1e3c72;
            color: white;
        }

        .btn-primary:hover {
            background: #152b54;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(30, 60, 114, 0.3);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-success {
            background: #28a745;
            color: white;
        }

        .btn-success:hover {
            background: #218838;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .btn-warning {
            background: #ffc107;
            color: #333;
        }

        .btn-warning:hover {
            background: #e0a800;
        }

        .btn-info {
            background: #17a2b8;
            color: white;
        }

        .btn-info:hover {
            background: #138496;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 13px;
        }

        .tree-item {
            padding: 8px 10px;
            margin: 3px 0;
            border-radius: 6px;
            cursor: pointer;
            transition: background 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }

        .tree-item:hover {
            background: #e9ecef;
        }

        .tree-item.selected {
            background: #1e3c72;
            color: white;
        }

        .tree-item.folder {
            font-weight: 600;
        }

        .tree-item.entry {
            font-size: 13px;
            padding-left: 28px;
        }

        .tree-children {
            margin-left: 15px;
        }

        .entry-item {
            background: #f8f9fa;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            transition: all 0.3s;
        }

        .entry-item:hover {
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
            border-color: #1e3c72;
        }

        .entry-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .entry-title {
            font-size: 1.3em;
            font-weight: 700;
            color: #1e3c72;
        }

        .entry-details {
            display: grid;
            grid-template-columns: 120px 1fr;
            gap: 12px;
            margin-bottom: 15px;
        }

        .entry-label {
            font-weight: 600;
            color: #666;
        }

        .entry-value {
            color: #333;
            word-break: break-all;
        }

        .password-hidden {
            font-family: monospace;
            letter-spacing: 3px;
        }

        .button-group {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.6);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: white;
            padding: 30px;
            border-radius: 15px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }

        .modal-header h2 {
            color: #1e3c72;
            font-size: 1.5em;
        }

        .close-modal {
            background: none;
            border: none;
            font-size: 28px;
            cursor: pointer;
            color: #999;
            padding: 0;
            width: 35px;
            height: 35px;
            line-height: 1;
        }

        .close-modal:hover {
            color: #333;
        }

        .custom-field {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 15px;
            border: 1px solid #dee2e6;
        }

        .custom-field-header {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }

        .attachment-item {
            background: #e9ecef;
            padding: 12px;
            border-radius: 6px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .attachment-name {
            font-weight: 600;
            color: #333;
        }

        .strength-meter {
            height: 6px;
            background: #e0e0e0;
            border-radius: 3px;
            margin-top: 8px;
            overflow: hidden;
        }

        .strength-bar {
            height: 100%;
            transition: all 0.3s;
            border-radius: 3px;
        }

        .strength-weak { background: #dc3545; width: 33%; }
        .strength-medium { background: #ffc107; width: 66%; }
        .strength-strong { background: #28a745; width: 100%; }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #28a745;
            color: white;
            padding: 15px 25px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            z-index: 10000;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #999;
        }

        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        .current-folder-indicator {
            background: #e7f3ff;
            border-left: 4px solid #1e3c72;
            padding: 12px;
            margin-bottom: 20px;
            border-radius: 4px;
            font-weight: 600;
            color: #1e3c72;
        }

        .search-box {
            flex: 1;
            min-width: 200px;
            max-width: 400px;
        }

        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                max-height: 250px;
            }
            
            .content-area {
                flex-direction: column;
            }

            .header-left {
                flex-direction: column;
                align-items: flex-start;
                gap: 8px;
            }
        }
    </style>
</head>
<body>
    <!-- Login/Startup Screen -->
    <div id="loginScreen" class="login-screen">
        <div class="login-container">
            <div class="login-header">
                <div class="icon">üîê</div>
                <h1>KeePass Manager</h1>
                <p>Gestione sicura delle password con crittografia AES-256</p>
            </div>

            <div class="button-group" style="margin-bottom: 30px;">
                <button class="btn-primary" style="flex: 1;" onclick="showCreateVault()">
                    ‚ûï Crea Nuovo Vault
                </button>
                <button class="btn-secondary" style="flex: 1;" onclick="showLoadVault()">
                    üìÇ Carica Vault
                </button>
            </div>

            <!-- Form Creazione Vault -->
            <div id="createVaultForm" style="display: none;">
                <h3 style="color: #1e3c72; margin-bottom: 20px;">Crea Nuovo Vault</h3>
                <div class="form-group">
                    <label for="newVaultName">Nome Vault</label>
                    <input type="text" id="newVaultName" placeholder="Il mio vault sicuro">
                </div>
                <div class="form-group">
                    <label for="newVaultPassword">Master Password *</label>
                    <input type="password" id="newVaultPassword" placeholder="Scegli una password forte">
                    <div class="strength-meter">
                        <div class="strength-bar" id="createStrengthBar"></div>
                    </div>
                </div>
                <div class="form-group">
                    <label for="newVaultPasswordConfirm">Conferma Password *</label>
                    <input type="password" id="newVaultPasswordConfirm" placeholder="Ripeti la password">
                </div>
                <div class="button-group">
                    <button class="btn-success" onclick="createNewVault()">üîí Crea Vault</button>
                    <button class="btn-secondary" onclick="hideAllForms()">Annulla</button>
                </div>
            </div>

            <!-- Form Caricamento Vault -->
<div id="loadVaultForm" style="display: none;">
    <h3 style="color: #1e3c72; margin-bottom: 20px;">Carica Vault Esistente</h3>
    
    <div class="form-group">
        <label for="vaultFile">File Vault (.kdbx, .xml, .encrypted)</label>
        <input type="file" id="vaultFile" accept=".kdbx,.xml,.encrypted">
    </div>
    
    <div class="form-group">
        <label for="vaultPassword">Master Password</label>
        <input type="password" id="vaultPassword" placeholder="Inserisci la master password">
    </div>

    <div class="button-group">
        <button class="btn-primary" onclick="loadVault()">üîì Apri Vault</button>
        <button id="btnBiometric" class="btn-info" style="display: none;" onclick="unlockWithBiometrics()">üß¨ Usa Impronta</button>
        <button class="btn-secondary" onclick="hideAllForms()">Annulla</button>
    </div>
</div>
        </div>
    </div>

    <!-- Main Application -->
    <div id="mainContainer" class="main-container">
        <!-- Header compatto -->
        <div class="header">
            <div class="header-left">
                <div class="vault-name" id="currentVaultName">üîê My Vault</div>
            </div>
            <div class="header-actions">
                <button class="icon-btn" onclick="showImportModal()" title="Importa XML">üì•</button>
                <button class="icon-btn" onclick="exportVault()" title="Esporta Vault">üíæ</button>
                <button class="icon-btn" onclick="closeVault()" title="Chiudi Vault">üö™</button>
            </div>
        </div>

        <!-- Toolbar -->
        <div class="toolbar">
            <button class="btn-primary btn-sm" onclick="showAddFolderModal()">üìÅ Cartella</button>
            <button class="btn-success btn-sm" onclick="showAddEntryModal()">‚ûï Entry</button>
            <button class="btn-info btn-sm" onclick="generatePassword()">üé≤ Password</button>
            <input type="text" id="searchBox" class="search-box" placeholder="üîç Cerca..." oninput="filterEntries(this.value)">
        </div>

        <div class="content-area">
            <div class="sidebar">
                <h3 style="margin-bottom: 12px; color: #1e3c72; font-size: 14px;">üìÇ STRUTTURA</h3>
                <div id="folderTree"></div>
            </div>

            <div class="main-content">
                <div class="current-folder-indicator" id="currentFolderIndicator">
                    üìÅ Root
                </div>
                <div id="entriesList"></div>
            </div>
        </div>
    </div>

    <!-- Modal Importa XML -->
    <div id="importModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üì• Importa da XML</h2>
                <button class="close-modal" onclick="closeImportModal()">√ó</button>
            </div>
            <div class="form-group">
                <label for="importFile">File XML KeePass</label>
                <input type="file" id="importFile" accept=".xml">
            </div>
            <div class="form-group">
                <label for="importPassword">Password (se criptato)</label>
                <input type="password" id="importPassword" placeholder="Lascia vuoto se non criptato">
            </div>
            <div class="form-group">
                <label for="importTarget">Cartella destinazione</label>
                <select id="importTarget">
                    <option value="">Root</option>
                </select>
            </div>
            <div class="button-group">
                <button class="btn-success" onclick="importXML()">üì• Importa</button>
                <button class="btn-secondary" onclick="closeImportModal()">Annulla</button>
            </div>
        </div>
    </div>

    <!-- Modal Nuova Cartella -->
    <div id="folderModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìÅ Nuova Cartella</h2>
                <button class="close-modal" onclick="closeFolderModal()">√ó</button>
            </div>
            <div class="form-group">
                <label for="folderName">Nome Cartella *</label>
                <input type="text" id="folderName" placeholder="es. Email, Banking">
            </div>
            <div class="form-group">
                <label for="parentFolder">Cartella Padre</label>
                <select id="parentFolder">
                    <option value="">Root</option>
                </select>
            </div>
            <div class="button-group">
                <button class="btn-primary" onclick="addFolder()">üíæ Crea</button>
                <button class="btn-secondary" onclick="closeFolderModal()">Annulla</button>
            </div>
        </div>
    </div>

    <!-- Modal Entry -->
    <div id="entryModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2 id="entryModalTitle">‚ûï Nuova Entry</h2>
                <button class="close-modal" onclick="closeEntryModal()">√ó</button>
            </div>
            
            <input type="hidden" id="editEntryId">
            
            <div class="form-group">
                <label for="entryTitle">Titolo *</label>
                <input type="text" id="entryTitle" placeholder="es. Gmail">
            </div>

            <div class="form-group">
                <label for="entryUsername">Username *</label>
                <input type="text" id="entryUsername" placeholder="user@example.com">
            </div>

            <div class="form-group">
                <label for="entryPassword">Password *</label>
                <input type="password" id="entryPassword" placeholder="Password">
                <div class="strength-meter">
                    <div class="strength-bar" id="entryStrengthBar"></div>
                </div>
            </div>

            <div class="form-group">
                <label for="entryUrl">URL</label>
                <input type="url" id="entryUrl" placeholder="https://example.com">
            </div>

            <div class="form-group">
                <label for="entryNotes">Note</label>
                <textarea id="entryNotes" placeholder="Note aggiuntive..."></textarea>
            </div>

            <div class="form-group">
                <label for="entryFolder">Cartella</label>
                <select id="entryFolder">
                    <option value="">Root</option>
                </select>
            </div>

            <div class="form-group">
                <label>Custom Fields</label>
                <div id="customFieldsList"></div>
                <button class="btn-secondary btn-sm" onclick="addCustomField()" style="margin-top: 10px;">
                    ‚ûï Campo Personalizzato
                </button>
            </div>

            <div class="form-group">
                <label>Allegati</label>
                <input type="file" id="attachmentFile" multiple>
                <div id="attachmentsList" style="margin-top: 10px;"></div>
            </div>

            <div class="button-group">
                <button class="btn-primary" onclick="saveEntry()">üíæ Salva</button>
                <button class="btn-success" onclick="generatePasswordForEntry()">üé≤ Genera</button>
                <button class="btn-secondary" onclick="closeEntryModal()">Annulla</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    
    <script>
let currentVaultName = "vault.json"; // Nome predefinito
        
async function loadVault() {
    const fileInput = document.getElementById('vaultFile');
    const passwordInput = document.getElementById('vaultPassword');
    const password = passwordInput.value;
    
    if (!fileInput.files.length || !password) {
        showNotification('‚ö†Ô∏è Seleziona file e inserisci password', 'error');
        return;
    }

    try {
        const file = fileInput.files[0];
        
        // Aggiorna il nome del vault PRIMA di qualsiasi altra operazione
        currentVaultName = file.name; 

        const content = await readFileAsText(file);
        
        // Caricamento dati (XML o Criptato)
        if (file.name.endsWith('.xml')) {
            await loadFromXML(content, password);
        } else {
            await loadEncryptedVault(content, password);
        }

        // Se arriviamo qui, la password √® corretta
        masterPassword = password;
        openMainApplication(); 
        showNotification('‚úÖ Vault aperto!');

        // Logica biometria migliorata
        if (window.PublicKeyCredential) {
            const isAvailable = await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
            
            if (isAvailable) {
                // Controlla se esiste gi√† una chiave biometrica per questo vault
                const storageKey = "bio_key_" + currentVaultName;
                const existingKey = localStorage.getItem(storageKey);
                
                // Solo se NON esiste gi√†, proponi di crearla
                if (!existingKey) {
                    setTimeout(() => setupBiometrics(masterPassword, currentVaultName), 1000);
                }
            }
        }
        
        passwordInput.value = ""; 
    } catch (error) {
        console.error(error);
        showNotification('‚ùå Errore: password errata o file non valido', 'error');
    }
}
// Controlla se il browser supporta la biometria all'avvio
// All'avvio della pagina


window.onload = async () => {
    // Controlla se il browser supporta la biometria
    if (window.PublicKeyCredential) {
        const isAvailable = await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
        if (isAvailable) {
            // Controlla se esistono chiavi biometriche salvate
            // Cerchiamo qualsiasi chiave che inizi con "bio_key_"
            let hasBioKey = false;
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                if (key && key.startsWith("bio_key_")) {
                    hasBioKey = true;
                    break;
                }
            }
            
            if (hasBioKey) {
                const btnBio = document.getElementById('btnBiometric');
                if (btnBio) btnBio.style.display = 'inline-block';
            }
        }
    }
};
        
        
// 1. Registra l'impronta (da chiamare dopo un login riuscito)
async function setupBiometrics(password, vaultName) { // <--- Aggiungi vaultName qui
    if (!confirm(`Vuoi abilitare l'impronta digitale per il vault "${vaultName}"?`)) return;

    // L'ID deve essere unico per questo vault, ma costante nel tempo.
    // Possiamo usare un hash del nome del file per generare un ID fisso.
    const encoder = new TextEncoder();
    const userId = encoder.encode(vaultName); 

    const options = {
        publicKey: {
            challenge: crypto.getRandomValues(new Uint8Array(32)),
            rp: { name: "KeePass Web" },
            user: { 
                id: userId, 
                name: vaultName,          // <--- Questo apparir√† nel gestore passkey
                displayName: vaultName    // <--- Questo apparir√† nel pop-up dell'impronta
            },
            pubKeyCredParams: [{ alg: -7, type: "public-key" }],
            authenticatorSelection: {
                residentKey: "required",
                userVerification: "required",
                authenticatorAttachment: "platform"
            },
            timeout: 60000
        }
    };

    try {
        const credential = await navigator.credentials.create(options);
        // Dentro setupBiometrics, dopo navigator.credentials.create:
        const storageKey = "bio_key_" + vaultName;
        const encrypted = CryptoJS.AES.encrypt(password, "BIO-SESSION-KEY").toString();
        localStorage.setItem(storageKey, encrypted);        showNotification("‚úÖ Biometria configurata per " + vaultName);
        
    } catch (err) {
        console.error(err);
        showNotification("‚ùå Errore configurazione biometria", "error");
    }
}

// 2. Sblocca con Impronta

async function unlockWithBiometrics() {
    const fileInput = document.getElementById('vaultFile');
    
    // Verifica se il file √® selezionato
    if (!fileInput.files.length) {
        showNotification("‚ö†Ô∏è Seleziona prima il file del vault", "warning");
        return;
    }
    
    currentVaultName = fileInput.files[0].name;
    const storageKey = "bio_key_" + currentVaultName;
    const encryptedPass = localStorage.getItem(storageKey);
    
    if (!encryptedPass) {
        showNotification("‚ö†Ô∏è Nessuna impronta configurata per questo vault", "warning");
        return;
    }

    // Prepara le opzioni per la verifica biometrica
    const options = {
        publicKey: {
            challenge: crypto.getRandomValues(new Uint8Array(32)),
            userVerification: "required",
            allowCredentials: [{
                id: new TextEncoder().encode(currentVaultName),
                type: 'public-key'
            }]
        }
    };

    try {
        // Verifica l'impronta
        await navigator.credentials.get(options); 
        
        // Decripta la password salvata
        const decryptedBytes = CryptoJS.AES.decrypt(encryptedPass, "BIO-SESSION-KEY");
        const savedPassword = decryptedBytes.toString(CryptoJS.enc.Utf8);

        if (savedPassword) {
            document.getElementById('vaultPassword').value = savedPassword;
            loadVault(); 
        } else {
            showNotification("‚ùå Errore nel recupero della password", "error");
        }
    } catch (e) {
        console.error(e);
        showNotification("‚ùå Autenticazione biometrica fallita", "error");
    }
}
        
        // Struttura dati vault
        let vaultData = {
            meta: {
                generator: "KeePass Compatible Password Manager",
                databaseName: "My Database",
                databaseDescription: "",
                defaultUserName: "",
                maintenanceHistoryDays: 365,
                color: "",
                masterKeyChanged: new Date().toISOString(),
                masterKeyChangeRec: -1,
                masterKeyChangeForce: -1,
                recycleBinEnabled: true,
                recycleBinUUID: null,
                recycleBinChanged: new Date().toISOString(),
                entryTemplatesGroup: null,
                entryTemplatesGroupChanged: new Date().toISOString(),
                historyMaxItems: 10,
                historyMaxSize: 6291456,
                lastSelectedGroup: null,
                lastTopVisibleGroup: null
            },
            root: {
                uuid: generateUUID(),
                name: "Root",
                notes: "",
                iconID: 48,
                times: {
                    creationTime: new Date().toISOString(),
                    lastModificationTime: new Date().toISOString(),
                    lastAccessTime: new Date().toISOString(),
                    expiryTime: new Date('2999-12-31').toISOString(),
                    expires: false,
                    usageCount: 0,
                    locationChanged: new Date().toISOString()
                },
                groups: [],
                entries: []
            }
        };

        let masterPassword = "";
        let currentVaultFile = null;
        let selectedFolderId = null;
        let selectedEntryId = null;
        let customFieldsCount = 0;
        let searchQuery = "";

        // Event listeners
        document.getElementById('newVaultPassword')?.addEventListener('input', function() {
            checkPasswordStrength(this.value, 'createStrengthBar');
        });

        document.getElementById('entryPassword')?.addEventListener('input', function() {
            checkPasswordStrength(this.value, 'entryStrengthBar');
        });

        // Funzioni UI Login
        function showCreateVault() {
            hideAllForms();
            document.getElementById('createVaultForm').style.display = 'block';
        }

// All'avvio della pagina
window.onload = async () => {
    // Verifichiamo se esiste una chiave biometrica salvata
    const hasBioKey = localStorage.getItem("vault_biometric_key");
    
    if (window.PublicKeyCredential && hasBioKey) {
        // Se esiste, rendiamo visibile il pulsante biometrico nel form
        const btnBio = document.getElementById('btnBiometric');
        if (btnBio) btnBio.style.display = 'inline-block';
    }
};

// Modifica la funzione che mostra il form per assicurarti che il tasto sia l√¨
async function loadVault() {
    const fileInput = document.getElementById('vaultFile');
    const passwordInput = document.getElementById('vaultPassword');
    const password = passwordInput.value;
    
    if (!fileInput.files.length || !password) {
        showNotification('‚ö†Ô∏è Seleziona file e inserisci password', 'error');
        return;
    }

    try {
        const file = fileInput.files[0];
        
        // Aggiorna il nome del vault PRIMA di qualsiasi altra operazione
        currentVaultName = file.name; 

        const content = await readFileAsText(file);
        
        // Caricamento dati (XML o Criptato)
        if (file.name.endsWith('.xml')) {
            await loadFromXML(content, password);
        } else {
            await loadEncryptedVault(content, password);
        }

        // Se arriviamo qui, la password √® corretta
        masterPassword = password;
        openMainApplication(); 
        showNotification('‚úÖ Vault aperto!');

        // Logica biometria migliorata
        if (window.PublicKeyCredential) {
            const isAvailable = await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
            
            if (isAvailable) {
                // Controlla se esiste gi√† una chiave biometrica per questo vault
                const storageKey = "bio_key_" + currentVaultName;
                const existingKey = localStorage.getItem(storageKey);
                
                // Solo se NON esiste gi√†, proponi di crearla
                if (!existingKey) {
                    setTimeout(() => setupBiometrics(masterPassword, currentVaultName), 1000);
                }
            }
        }
        
        passwordInput.value = ""; 
    } catch (error) {
        console.error(error);
        showNotification('‚ùå Errore: password errata o file non valido', 'error');
    }
}
        
// Assicuriamoci che il controllo avvenga anche al caricamento pagina
window.addEventListener('DOMContentLoaded', () => {
    const biometricKey = localStorage.getItem("vault_biometric_key");
    if (biometricKey) {
        const btnBio = document.getElementById('btnBiometric');
        if (btnBio) btnBio.style.display = 'inline-block';
    }
});
        function hideAllForms() {
            document.getElementById('createVaultForm').style.display = 'none';
            document.getElementById('loadVaultForm').style.display = 'none';
        }

        // Genera UUID v4
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = Math.random() * 16 | 0;
                const v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }

        // Crea nuovo vault
        function createNewVault() {
            const name = document.getElementById('newVaultName').value.trim();
            const password = document.getElementById('newVaultPassword').value;
            const confirmPassword = document.getElementById('newVaultPasswordConfirm').value;

            if (!password) {
                showNotification('‚ö†Ô∏è Inserisci una master password', 'error');
                return;
            }

            if (password !== confirmPassword) {
                showNotification('‚ö†Ô∏è Le password non coincidono', 'error');
                return;
            }

            if (password.length < 8) {
                showNotification('‚ö†Ô∏è Password minimo 8 caratteri', 'error');
                return;
            }

            masterPassword = password;
            vaultData.meta.databaseName = name || "My Secure Vault";
            vaultData.meta.masterKeyChanged = new Date().toISOString();

            openMainApplication();
            showNotification('‚úÖ Vault creato con successo!');
        }

        // Carica vault esistente - FIX PRINCIPALE
        // Leggi file come testo
        function readFileAsText(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = reject;
                reader.readAsText(file);
            });
        }

        // Carica da XML KeePass 2.x
        function loadFromXML(xmlString, password) {
            const parser = new DOMParser();
            let xmlDoc = parser.parseFromString(xmlString, "text/xml");

            // Verifica se √® criptato
            const encryptedNode = xmlDoc.querySelector('Encrypted');
            if (encryptedNode && encryptedNode.textContent === 'true') {
                const encryptedData = xmlDoc.querySelector('EncryptedData')?.textContent;
                if (encryptedData) {
                    const decrypted = decryptAES(encryptedData, password);
                    if (!decrypted) {
                        throw new Error('Password errata');
                    }
                    xmlString = decrypted;
                    xmlDoc = parser.parseFromString(xmlString, "text/xml");
                }
            }

            // Parse Meta
            const metaNode = xmlDoc.querySelector('Meta');
            if (metaNode) {
                vaultData.meta.databaseName = metaNode.querySelector('DatabaseName')?.textContent || 'Database';
                vaultData.meta.databaseDescription = metaNode.querySelector('DatabaseDescription')?.textContent || '';
                vaultData.meta.defaultUserName = metaNode.querySelector('DefaultUserName')?.textContent || '';
            }

            // Parse Root Group
            const rootNode = xmlDoc.querySelector('Root > Group');
            if (rootNode) {
                vaultData.root = parseGroup(rootNode);
            }
        }

        // Parse gruppo ricorsivo
        function parseGroup(groupNode) {
            const group = {
                uuid: groupNode.querySelector('UUID')?.textContent || generateUUID(),
                name: groupNode.querySelector('Name')?.textContent || 'Group',
                notes: groupNode.querySelector('Notes')?.textContent || '',
                iconID: parseInt(groupNode.querySelector('IconID')?.textContent || '48'),
                times: parseTimes(groupNode.querySelector('Times')),
                groups: [],
                entries: []
            };

            const subGroups = groupNode.querySelectorAll(':scope > Group');
            subGroups.forEach(subGroup => {
                group.groups.push(parseGroup(subGroup));
            });

            const entryNodes = groupNode.querySelectorAll(':scope > Entry');
            entryNodes.forEach(entryNode => {
                group.entries.push(parseEntry(entryNode));
            });

            return group;
        }

        // Parse entry
        function parseEntry(entryNode) {
            const entry = {
                uuid: entryNode.querySelector('UUID')?.textContent || generateUUID(),
                iconID: parseInt(entryNode.querySelector('IconID')?.textContent || '0'),
                times: parseTimes(entryNode.querySelector('Times')),
                strings: {},
                binaries: [],
                autoType: {
                    enabled: true,
                    dataTransferObfuscation: 0,
                    sequence: '{USERNAME}{TAB}{PASSWORD}{ENTER}'
                },
                history: []
            };

            const stringNodes = entryNode.querySelectorAll('String');
            stringNodes.forEach(stringNode => {
                const key = stringNode.querySelector('Key')?.textContent;
                const valueNode = stringNode.querySelector('Value');
                const value = valueNode?.textContent || '';
                const isProtected = valueNode?.getAttribute('Protected') === 'True';
                
                if (key) {
                    entry.strings[key] = { value, protected: isProtected };
                }
            });

            const binaryNodes = entryNode.querySelectorAll('Binary');
            binaryNodes.forEach(binaryNode => {
                const key = binaryNode.querySelector('Key')?.textContent;
                const valueNode = binaryNode.querySelector('Value');
                const value = valueNode?.textContent || '';
                
                if (key) {
                    entry.binaries.push({ 
                        name: key, 
                        data: value,
                        compressed: valueNode?.getAttribute('Compressed') === 'True'
                    });
                }
            });

            return entry;
        }

        // Parse times
        function parseTimes(timesNode) {
            if (!timesNode) {
                return {
                    creationTime: new Date().toISOString(),
                    lastModificationTime: new Date().toISOString(),
                    lastAccessTime: new Date().toISOString(),
                    expiryTime: new Date('2999-12-31').toISOString(),
                    expires: false,
                    usageCount: 0,
                    locationChanged: new Date().toISOString()
                };
            }

            return {
                creationTime: timesNode.querySelector('CreationTime')?.textContent || new Date().toISOString(),
                lastModificationTime: timesNode.querySelector('LastModificationTime')?.textContent || new Date().toISOString(),
                lastAccessTime: timesNode.querySelector('LastAccessTime')?.textContent || new Date().toISOString(),
                expiryTime: timesNode.querySelector('ExpiryTime')?.textContent || new Date('2999-12-31').toISOString(),
                expires: timesNode.querySelector('Expires')?.textContent === 'True',
                usageCount: parseInt(timesNode.querySelector('UsageCount')?.textContent || '0'),
                locationChanged: timesNode.querySelector('LocationChanged')?.textContent || new Date().toISOString()
            };
        }

        // Carica vault criptato - FIX PRINCIPALE
// Cerca la parte dove gestisci il caricamento e aggiornala cos√¨:
async function loadEncryptedVault(content, password) {
    // Il 'content' √® il testo del file JSON
    const decrypted = decryptAES(content, password);
    
    if (!decrypted) {
        throw new Error('Password errata o file non valido');
    }
    
    // Una volta decriptato, carichiamo i dati nel vault
    vaultData = JSON.parse(decrypted);
    renderFolderTree();
    renderEntries();
}

        // Mostra modal importazione
        function showImportModal() {
            updateImportTargetSelect();
            document.getElementById('importModal').classList.add('active');
        }

        function closeImportModal() {
            document.getElementById('importModal').classList.remove('active');
            document.getElementById('importFile').value = '';
            document.getElementById('importPassword').value = '';
            document.getElementById('importTarget').value = '';
        }

        function updateImportTargetSelect() {
            const select = document.getElementById('importTarget');
            select.innerHTML = '<option value="">Root</option>';
            addGroupOptions(vaultData.root, select, 0);
        }

        // Importa XML
        async function importXML() {
            const fileInput = document.getElementById('importFile');
            const password = document.getElementById('importPassword').value;
            const targetFolderId = document.getElementById('importTarget').value;

            if (!fileInput.files.length) {
                showNotification('‚ö†Ô∏è Seleziona un file XML', 'error');
                return;
            }

            try {
                const file = fileInput.files[0];
                const content = await readFileAsText(file);
                
                const parser = new DOMParser();
                let xmlDoc = parser.parseFromString(content, "text/xml");

                const encryptedNode = xmlDoc.querySelector('Encrypted');
                if (encryptedNode && encryptedNode.textContent === 'true') {
                    if (!password) {
                        showNotification('‚ö†Ô∏è File criptato, inserisci password', 'error');
                        return;
                    }
                    const encryptedData = xmlDoc.querySelector('EncryptedData')?.textContent;
                    if (encryptedData) {
                        const decrypted = decryptAES(encryptedData, password);
                        xmlDoc = parser.parseFromString(decrypted, "text/xml");
                    }
                }

                const rootNode = xmlDoc.querySelector('Root > Group');
                if (!rootNode) {
                    showNotification('‚ö†Ô∏è File XML non valido', 'error');
                    return;
                }

                const importedGroup = parseGroup(rootNode);
                const targetGroup = targetFolderId ? findGroupById(vaultData.root, targetFolderId) : vaultData.root;
                
                if (!targetGroup) {
                    showNotification('‚ö†Ô∏è Cartella target non trovata', 'error');
                    return;
                }

                importedGroup.groups.forEach(group => {
                    targetGroup.groups.push(group);
                });
                
                importedGroup.entries.forEach(entry => {
                    targetGroup.entries.push(entry);
                });

                renderFolderTree();
                renderEntries();
                closeImportModal();
                
                showNotification(`‚úÖ Importati ${importedGroup.groups.length} cartelle e ${importedGroup.entries.length} entries`);
            } catch (error) {
                console.error('Errore importazione:', error);
                showNotification('‚ùå Errore importazione: ' + error.message, 'error');
            }
        }

        // Apri applicazione
        function openMainApplication() {
            document.getElementById('loginScreen').style.display = 'none';
            document.getElementById('mainContainer').style.display = 'flex';
            document.getElementById('currentVaultName').textContent = 'üîê ' + vaultData.meta.databaseName;
            
            renderFolderTree();
            renderEntries();
            updateCurrentFolderIndicator();
        }

        function updateCurrentFolderIndicator() {
            const indicator = document.getElementById('currentFolderIndicator');
            if (selectedFolderId) {
                const group = findGroupById(vaultData.root, selectedFolderId);
                if (group) {
                    const path = getGroupPath(vaultData.root, selectedFolderId);
                    indicator.textContent = 'üìÅ ' + path.join(' / ');
                }
            } else {
                indicator.textContent = 'üìÅ Root';
            }
        }

        function getGroupPath(group, targetId, currentPath = []) {
            if (group.uuid === targetId) {
                return [...currentPath, group.name];
            }
            
            for (const subGroup of group.groups) {
                const path = getGroupPath(subGroup, targetId, [...currentPath, group.name]);
                if (path) return path;
            }
            
            return null;
        }

        // Chiudi vault
        function closeVault() {
            if (confirm('Chiudere il vault? Assicurati di aver salvato.')) {
                document.getElementById('loginScreen').style.display = 'flex';
                document.getElementById('mainContainer').style.display = 'none';
                
                document.getElementById('newVaultName').value = '';
                document.getElementById('newVaultPassword').value = '';
                document.getElementById('newVaultPasswordConfirm').value = '';
                document.getElementById('vaultPassword').value = '';
                hideAllForms();
                
                masterPassword = '';
                selectedFolderId = null;
                selectedEntryId = null;
            }
        }

        // Esporta vault
// Sostituisci la tua funzione exportVault con questa:
function exportVault() {
    try {
        const json = JSON.stringify(vaultData);
        
        // 1. Criptiamo i dati ottenendo l'oggetto completo
        const encryptedPayload = encryptAES(json, masterPassword);
        
        // 2. Trasformiamo l'oggetto in stringa JSON per il salvataggio
        const fileContent = JSON.stringify(encryptedPayload);
        
        // 3. Download
        const fileName = (vaultData.meta.databaseName || 'vault') + '.kdbx';
        downloadFile(fileContent, fileName, 'application/json');
        
        showNotification('‚úÖ Vault esportato con cifratura rinforzata');
    } catch (e) {
        console.error(e);
        showNotification('‚ùå Errore durante l\'esportazione', 'error');
    }
}

// Funzione helper per il download (aggiungila se manca)
function downloadFile(content, fileName, contentType) {
    const a = document.createElement("a");
    const file = new Blob([content], { type: contentType });
    a.href = URL.createObjectURL(file);
    a.download = fileName;
    a.click();
}

        // Esporta in XML
        function exportToXML() {
            let xml = '<?xml version="1.0" encoding="utf-8" standalone="yes"?>\n';
            xml += '<KeePassFile>\n';
            
            xml += '  <Meta>\n';
            xml += `    <Generator>${escapeXml(vaultData.meta.generator)}</Generator>\n`;
            xml += `    <DatabaseName>${escapeXml(vaultData.meta.databaseName)}</DatabaseName>\n`;
            xml += `    <DatabaseDescription>${escapeXml(vaultData.meta.databaseDescription)}</DatabaseDescription>\n`;
            xml += `    <DefaultUserName>${escapeXml(vaultData.meta.defaultUserName)}</DefaultUserName>\n`;
            xml += `    <MaintenanceHistoryDays>${vaultData.meta.maintenanceHistoryDays}</MaintenanceHistoryDays>\n`;
            xml += `    <MasterKeyChanged>${vaultData.meta.masterKeyChanged}</MasterKeyChanged>\n`;
            xml += `    <RecycleBinEnabled>${vaultData.meta.recycleBinEnabled}</RecycleBinEnabled>\n`;
            xml += '  </Meta>\n';
            
            xml += '  <Root>\n';
            xml += groupToXML(vaultData.root, 2);
            xml += '  </Root>\n';
            xml += '</KeePassFile>';
            
            const encrypted = encryptAES(xml, masterPassword);
            
            let encryptedXml = '<?xml version="1.0" encoding="utf-8" standalone="yes"?>\n';
            encryptedXml += '<KeePassFile>\n';
            encryptedXml += '  <Encrypted>true</Encrypted>\n';
            encryptedXml += `  <EncryptedData>${encrypted}</EncryptedData>\n`;
            encryptedXml += '</KeePassFile>';
            
            downloadFile(encryptedXml, vaultData.meta.databaseName + '.xml', 'text/xml');
            showNotification('‚úÖ Vault esportato in XML');
        }

        function groupToXML(group, indent = 0) {
            const ind = '  '.repeat(indent);
            let xml = '';
            
            xml += `${ind}<Group>\n`;
            xml += `${ind}  <UUID>${group.uuid}</UUID>\n`;
            xml += `${ind}  <Name>${escapeXml(group.name)}</Name>\n`;
            xml += `${ind}  <Notes>${escapeXml(group.notes)}</Notes>\n`;
            xml += `${ind}  <IconID>${group.iconID}</IconID>\n`;
            xml += timesToXML(group.times, indent + 1);
            
            group.entries.forEach(entry => {
                xml += entryToXML(entry, indent + 1);
            });
            
            group.groups.forEach(subGroup => {
                xml += groupToXML(subGroup, indent + 1);
            });
            
            xml += `${ind}</Group>\n`;
            return xml;
        }

        function entryToXML(entry, indent = 0) {
            const ind = '  '.repeat(indent);
            let xml = '';
            
            xml += `${ind}<Entry>\n`;
            xml += `${ind}  <UUID>${entry.uuid}</UUID>\n`;
            xml += `${ind}  <IconID>${entry.iconID}</IconID>\n`;
            xml += timesToXML(entry.times, indent + 1);
            
            for (const [key, value] of Object.entries(entry.strings)) {
                xml += `${ind}  <String>\n`;
                xml += `${ind}    <Key>${escapeXml(key)}</Key>\n`;
                xml += `${ind}    <Value${value.protected ? ' Protected="True"' : ''}>${escapeXml(value.value)}</Value>\n`;
                xml += `${ind}  </String>\n`;
            }
            
            entry.binaries.forEach(binary => {
                xml += `${ind}  <Binary>\n`;
                xml += `${ind}    <Key>${escapeXml(binary.name)}</Key>\n`;
                xml += `${ind}    <Value${binary.compressed ? ' Compressed="True"' : ''}>${binary.data}</Value>\n`;
                xml += `${ind}  </Binary>\n`;
            });
            
            xml += `${ind}</Entry>\n`;
            return xml;
        }

        function timesToXML(times, indent = 0) {
            const ind = '  '.repeat(indent);
            let xml = '';
            
            xml += `${ind}<Times>\n`;
            xml += `${ind}  <CreationTime>${times.creationTime}</CreationTime>\n`;
            xml += `${ind}  <LastModificationTime>${times.lastModificationTime}</LastModificationTime>\n`;
            xml += `${ind}  <LastAccessTime>${times.lastAccessTime}</LastAccessTime>\n`;
            xml += `${ind}  <ExpiryTime>${times.expiryTime}</ExpiryTime>\n`;
            xml += `${ind}  <Expires>${times.expires}</Expires>\n`;
            xml += `${ind}  <UsageCount>${times.usageCount}</UsageCount>\n`;
            xml += `${ind}  <LocationChanged>${times.locationChanged}</LocationChanged>\n`;
            xml += `${ind}</Times>\n`;
            
            return xml;
        }

//################################################

const CRYPTO_CONFIG = {
    iterations: 100000,
    keySize: 256 / 32,
    saltSize: 128 / 8,
    ivSize: 128 / 8
};

function exportEncrypted() {
    const json = JSON.stringify(vaultData);
    const encryptedPayload = encryptAES(json, masterPassword);
    const fileContent = JSON.stringify(encryptedPayload);
    
    downloadFile(fileContent, vaultData.meta.databaseName + '.kdbx', 'application/json');
    showNotification('‚úÖ Vault protetto con AES-256 + HMAC');
}

function encryptAES(data, password) {
    // Genera Salt e IV casuali
    const salt = CryptoJS.lib.WordArray.random(CRYPTO_CONFIG.saltSize);
    const iv = CryptoJS.lib.WordArray.random(CRYPTO_CONFIG.ivSize);

    // Deriva la chiave tramite PBKDF2
    const key = CryptoJS.PBKDF2(password, salt, {
        keySize: CRYPTO_CONFIG.keySize,
        iterations: CRYPTO_CONFIG.iterations
    });

    // Cifra
    const encrypted = CryptoJS.AES.encrypt(data, key, {
        iv: iv,
        padding: CryptoJS.pad.Pkcs7,
        mode: CryptoJS.mode.CBC
    });

    const ciphertext = encrypted.toString();

    // CALCOLO HMAC: Firma il testo cifrato usando la chiave derivata
    const hmac = CryptoJS.HmacSHA256(ciphertext, key).toString();

    return {
        ciphertext: ciphertext,
        salt: salt.toString(),
        iv: iv.toString(),
        hmac: hmac,
        iterations: CRYPTO_CONFIG.iterations
    };
}

function decryptAES(encryptedPayload, password) {
    try {
        // Se l'input √® stringa (dal file), lo trasformiamo in oggetto
        const data = typeof encryptedPayload === 'string' ? JSON.parse(encryptedPayload) : encryptedPayload;

        const salt = CryptoJS.enc.Hex.parse(data.salt);
        const iv = CryptoJS.enc.Hex.parse(data.iv);

        // Rigenera la chiave con i parametri del file
        const key = CryptoJS.PBKDF2(password, salt, {
            keySize: CRYPTO_CONFIG.keySize,
            iterations: data.iterations || CRYPTO_CONFIG.iterations
        });

        // VERIFICA HMAC: Integrit√† del file
        if (data.hmac) {
            const checkHmac = CryptoJS.HmacSHA256(data.ciphertext, key).toString();
            if (checkHmac !== data.hmac) {
                throw new Error("HMAC_FAIL: File manomesso o password errata");
            }
        }

        // Decifra
        const bytes = CryptoJS.AES.decrypt(data.ciphertext, key, {
            iv: iv,
            padding: CryptoJS.pad.Pkcs7,
            mode: CryptoJS.mode.CBC
        });

        const decrypted = bytes.toString(CryptoJS.enc.Utf8);
        if (!decrypted) throw new Error("DECRYPT_FAIL");

        return decrypted;
    } catch (e) {
        console.error("Errore decrittazione:", e.message);
        return null;
    }
}
//################################################
        function escapeXml(unsafe) {
            if (!unsafe) return '';
            return unsafe.replace(/[<>&'"]/g, function (c) {
                switch (c) {
                    case '<': return '&lt;';
                    case '>': return '&gt;';
                    case '&': return '&amp;';
                    case '\'': return '&apos;';
                    case '"': return '&quot;';
                }
            });
        }

        function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // Modals
        function showAddFolderModal() {
            updateParentFolderSelect();
            if (selectedFolderId) {
                document.getElementById('parentFolder').value = selectedFolderId;
            }
            document.getElementById('folderModal').classList.add('active');
        }

        function closeFolderModal() {
            document.getElementById('folderModal').classList.remove('active');
            document.getElementById('folderName').value = '';
            document.getElementById('parentFolder').value = '';
        }

        function showAddEntryModal() {
            document.getElementById('entryModalTitle').textContent = '‚ûï Nuova Entry';
            document.getElementById('editEntryId').value = '';
            document.getElementById('entryTitle').value = '';
            document.getElementById('entryUsername').value = '';
            document.getElementById('entryPassword').value = '';
            document.getElementById('entryUrl').value = '';
            document.getElementById('entryNotes').value = '';
            document.getElementById('customFieldsList').innerHTML = '';
            document.getElementById('attachmentsList').innerHTML = '';
            customFieldsCount = 0;
            
            updateEntryFolderSelect();
            if (selectedFolderId) {
                document.getElementById('entryFolder').value = selectedFolderId;
            }
            document.getElementById('entryModal').classList.add('active');
        }

        function closeEntryModal() {
            document.getElementById('entryModal').classList.remove('active');
        }

        // Aggiungi cartella
        function addFolder() {
            const name = document.getElementById('folderName').value.trim();
            const parentId = document.getElementById('parentFolder').value;

            if (!name) {
                showNotification('‚ö†Ô∏è Inserisci un nome', 'error');
                return;
            }

            const newGroup = {
                uuid: generateUUID(),
                name: name,
                notes: '',
                iconID: 48,
                times: {
                    creationTime: new Date().toISOString(),
                    lastModificationTime: new Date().toISOString(),
                    lastAccessTime: new Date().toISOString(),
                    expiryTime: new Date('2999-12-31').toISOString(),
                    expires: false,
                    usageCount: 0,
                    locationChanged: new Date().toISOString()
                },
                groups: [],
                entries: []
            };

            if (parentId) {
                const parentGroup = findGroupById(vaultData.root, parentId);
                if (parentGroup) {
                    parentGroup.groups.push(newGroup);
                }
            } else {
                vaultData.root.groups.push(newGroup);
            }

            renderFolderTree();
            closeFolderModal();
            showNotification('‚úÖ Cartella creata');
        }

        // Salva entry
        async function saveEntry() {
            const editId = document.getElementById('editEntryId').value;
            const title = document.getElementById('entryTitle').value.trim();
            const username = document.getElementById('entryUsername').value.trim();
            const password = document.getElementById('entryPassword').value;
            const url = document.getElementById('entryUrl').value.trim();
            const notes = document.getElementById('entryNotes').value.trim();
            const folderId = document.getElementById('entryFolder').value;

            if (!title || !username || !password) {
                showNotification('‚ö†Ô∏è Compila i campi obbligatori', 'error');
                return;
            }

            const customFields = {};
            const customFieldInputs = document.querySelectorAll('.custom-field');
            customFieldInputs.forEach(field => {
                const key = field.querySelector('.custom-field-key').value.trim();
                const value = field.querySelector('.custom-field-value').value.trim();
                const isProtected = field.querySelector('.custom-field-protected').checked;
                
                if (key) {
                    customFields[key] = { value, protected: isProtected };
                }
            });

            const binaries = [];
            const fileInput = document.getElementById('attachmentFile');
            
            const readFileAsBase64 = (file) => {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const base64 = e.target.result.split(',')[1];
                        resolve({
                            name: file.name,
                            data: base64,
                            compressed: false
                        });
                    };
                    reader.onerror = reject;
                    reader.readAsDataURL(file);
                });
            };

            if (fileInput.files.length > 0) {
                const filePromises = Array.from(fileInput.files).map(readFileAsBase64);
                const filesData = await Promise.all(filePromises);
                binaries.push(...filesData);
            }

            const entry = {
                uuid: editId || generateUUID(),
                iconID: 0,
                times: editId ? {
                    ...findEntryById(vaultData.root, editId).times,
                    lastModificationTime: new Date().toISOString(),
                    lastAccessTime: new Date().toISOString()
                } : {
                    creationTime: new Date().toISOString(),
                    lastModificationTime: new Date().toISOString(),
                    lastAccessTime: new Date().toISOString(),
                    expiryTime: new Date('2999-12-31').toISOString(),
                    expires: false,
                    usageCount: 0,
                    locationChanged: new Date().toISOString()
                },
                strings: {
                    Title: { value: title, protected: false },
                    UserName: { value: username, protected: false },
                    Password: { value: password, protected: true },
                    URL: { value: url, protected: false },
                    Notes: { value: notes, protected: false },
                    ...customFields
                },
                binaries: binaries,
                autoType: {
                    enabled: true,
                    dataTransferObfuscation: 0,
                    sequence: '{USERNAME}{TAB}{PASSWORD}{ENTER}'
                },
                history: []
            };

            if (editId) {
                const result = findAndReplaceEntry(vaultData.root, editId, entry);
                if (result) {
                    showNotification('‚úÖ Entry aggiornata');
                }
            } else {
                const targetGroup = folderId ? findGroupById(vaultData.root, folderId) : vaultData.root;
                if (targetGroup) {
                    targetGroup.entries.push(entry);
                    showNotification('‚úÖ Entry creata');
                }
            }

            renderFolderTree();
            renderEntries();
            closeEntryModal();
        }

        function findGroupById(group, id) {
            if (group.uuid === id) return group;
            
            for (const subGroup of group.groups) {
                const found = findGroupById(subGroup, id);
                if (found) return found;
            }
            
            return null;
        }

        function findEntryById(group, id) {
            for (const entry of group.entries) {
                if (entry.uuid === id) return entry;
            }
            
            for (const subGroup of group.groups) {
                const found = findEntryById(subGroup, id);
                if (found) return found;
            }
            
            return null;
        }

        function findAndReplaceEntry(group, id, newEntry) {
            for (let i = 0; i < group.entries.length; i++) {
                if (group.entries[i].uuid === id) {
                    group.entries[i] = newEntry;
                    return true;
                }
            }
            
            for (const subGroup of group.groups) {
                if (findAndReplaceEntry(subGroup, id, newEntry)) {
                    return true;
                }
            }
            
            return false;
        }

        function deleteEntry(id) {
            if (confirm('Eliminare questa entry?')) {
                if (deleteEntryById(vaultData.root, id)) {
                    renderFolderTree();
                    renderEntries();
                    showNotification('üóëÔ∏è Entry eliminata');
                }
            }
        }

        function deleteEntryById(group, id) {
            for (let i = 0; i < group.entries.length; i++) {
                if (group.entries[i].uuid === id) {
                    group.entries.splice(i, 1);
                    return true;
                }
            }
            
            for (const subGroup of group.groups) {
                if (deleteEntryById(subGroup, id)) {
                    return true;
                }
            }
            
            return false;
        }

        function editEntry(id) {
            const entry = findEntryById(vaultData.root, id);
            if (!entry) return;

            document.getElementById('entryModalTitle').textContent = '‚úèÔ∏è Modifica Entry';
            document.getElementById('editEntryId').value = id;
            document.getElementById('entryTitle').value = entry.strings.Title?.value || '';
            document.getElementById('entryUsername').value = entry.strings.UserName?.value || '';
            document.getElementById('entryPassword').value = entry.strings.Password?.value || '';
            document.getElementById('entryUrl').value = entry.strings.URL?.value || '';
            document.getElementById('entryNotes').value = entry.strings.Notes?.value || '';

            const customFieldsList = document.getElementById('customFieldsList');
            customFieldsList.innerHTML = '';
            customFieldsCount = 0;
            
            const standardFields = ['Title', 'UserName', 'Password', 'URL', 'Notes'];
            for (const [key, value] of Object.entries(entry.strings)) {
                if (!standardFields.includes(key)) {
                    addCustomField(key, value.value, value.protected);
                }
            }

            const attachmentsList = document.getElementById('attachmentsList');
            attachmentsList.innerHTML = '';
            entry.binaries.forEach(binary => {
                const div = document.createElement('div');
                div.className = 'attachment-item';
                div.innerHTML = `<div class="attachment-name">üìé ${escapeHtml(binary.name)}</div>`;
                attachmentsList.appendChild(div);
            });

            updateEntryFolderSelect();
            document.getElementById('entryModal').classList.add('active');
        }

        function addCustomField(key = '', value = '', isProtected = false) {
            const customFieldsList = document.getElementById('customFieldsList');
            const fieldId = customFieldsCount++;
            
            const div = document.createElement('div');
            div.className = 'custom-field';
            div.innerHTML = `
                <div class="custom-field-header">
                    <input type="text" class="custom-field-key" placeholder="Nome campo" value="${escapeHtml(key)}" style="flex: 1;">
                    <label style="display: flex; align-items: center; gap: 5px;">
                        <input type="checkbox" class="custom-field-protected" ${isProtected ? 'checked' : ''}>
                        Protetto
                    </label>
                    <button class="btn-danger btn-sm" onclick="this.parentElement.parentElement.remove()">üóëÔ∏è</button>
                </div>
                <input type="text" class="custom-field-value" placeholder="Valore" value="${escapeHtml(value)}">
            `;
            
            customFieldsList.appendChild(div);
        }

        function updateParentFolderSelect() {
            const select = document.getElementById('parentFolder');
            select.innerHTML = '<option value="">Root</option>';
            addGroupOptions(vaultData.root, select, 0);
        }

        function updateEntryFolderSelect() {
            const select = document.getElementById('entryFolder');
            select.innerHTML = '<option value="">Root</option>';
            addGroupOptions(vaultData.root, select, 0);
        }

        function addGroupOptions(group, select, level) {
            group.groups.forEach(subGroup => {
                const option = document.createElement('option');
                option.value = subGroup.uuid;
                option.textContent = '  '.repeat(level) + 'üìÅ ' + subGroup.name;
                select.appendChild(option);
                addGroupOptions(subGroup, select, level + 1);
            });
        }

        // Render albero con entries
        function renderFolderTree() {
            const container = document.getElementById('folderTree');
            container.innerHTML = '';
            
            const rootItem = document.createElement('div');
            rootItem.className = 'tree-item folder' + (selectedFolderId === null && !selectedEntryId ? ' selected' : '');
            rootItem.innerHTML = 'üìÅ Root';
            rootItem.onclick = () => selectFolder(null);
            container.appendChild(rootItem);
            
            // Mostra entries root
            if (selectedFolderId === null && !searchQuery) {
                vaultData.root.entries.forEach(entry => {
                    const entryItem = createEntryTreeItem(entry);
                    container.appendChild(entryItem);
                });
            }
            
            renderGroupTree(vaultData.root, container, 0);
        }

        function renderGroupTree(group, container, level) {
            group.groups.forEach(subGroup => {
                const item = document.createElement('div');
                item.className = 'tree-item folder' + (selectedFolderId === subGroup.uuid && !selectedEntryId ? ' selected' : '');
                item.style.marginLeft = `${level * 15}px`;
                item.innerHTML = 'üìÅ ' + escapeHtml(subGroup.name);
                item.onclick = (e) => {
                    e.stopPropagation();
                    selectFolder(subGroup.uuid);
                };
                container.appendChild(item);
                
                // Mostra entries se cartella selezionata
                if (selectedFolderId === subGroup.uuid && !searchQuery) {
                    subGroup.entries.forEach(entry => {
                        const entryItem = createEntryTreeItem(entry);
                        entryItem.style.marginLeft = `${(level + 1) * 15}px`;
                        container.appendChild(entryItem);
                    });
                }
                
                renderGroupTree(subGroup, container, level + 1);
            });
        }

        function createEntryTreeItem(entry) {
            const item = document.createElement('div');
            item.className = 'tree-item entry' + (selectedEntryId === entry.uuid ? ' selected' : '');
            item.innerHTML = 'üîë ' + escapeHtml(entry.strings.Title?.value || 'Untitled');
            item.onclick = (e) => {
                e.stopPropagation();
                selectEntry(entry.uuid);
            };
            return item;
        }

        function selectFolder(folderId) {
            selectedFolderId = folderId;
            selectedEntryId = null;
            renderFolderTree();
            renderEntries();
            updateCurrentFolderIndicator();
        }

        function selectEntry(entryId) {
            selectedEntryId = entryId;
            renderFolderTree();
            renderEntryDetail(entryId);
        }

        function renderEntryDetail(entryId) {
            const entry = findEntryById(vaultData.root, entryId);
            if (!entry) return;

            const container = document.getElementById('entriesList');
            const title = entry.strings.Title?.value || 'Untitled';
            const username = entry.strings.UserName?.value || '';
            const password = entry.strings.Password?.value || '';
            const url = entry.strings.URL?.value || '';
            const notes = entry.strings.Notes?.value || '';
            
            const standardFields = ['Title', 'UserName', 'Password', 'URL', 'Notes'];
            const customFields = Object.entries(entry.strings)
                .filter(([key]) => !standardFields.includes(key))
                .map(([key, value]) => `
                    <span class="entry-label">${escapeHtml(key)}:</span>
                    <span class="entry-value">${value.protected ? '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢' : escapeHtml(value.value)}</span>
                `).join('');
            
            container.innerHTML = `
                <div class="entry-item">
                    <div class="entry-header">
                        <div class="entry-title">üîë ${escapeHtml(title)}</div>
                    </div>
                    
                    <div class="entry-details">
                        <span class="entry-label">Username:</span>
                        <span class="entry-value">${escapeHtml(username)}</span>
                        
                        <span class="entry-label">Password:</span>
                        <span class="entry-value password-hidden" id="pwd-${entry.uuid}">‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢</span>
                        
                        ${url ? `
                            <span class="entry-label">URL:</span>
                            <span class="entry-value"><a href="${escapeHtml(url)}" target="_blank">${escapeHtml(url)}</a></span>
                        ` : ''}
                        
                        ${notes ? `
                            <span class="entry-label">Note:</span>
                            <span class="entry-value">${escapeHtml(notes)}</span>
                        ` : ''}
                        
                        ${customFields}
                        
                        ${entry.binaries.length > 0 ? `
                            <span class="entry-label">Allegati:</span>
                            <span class="entry-value">${entry.binaries.map(b => 'üìé ' + escapeHtml(b.name)).join(', ')}</span>
                        ` : ''}
                    </div>
                    
                    <div class="button-group">
                        <button class="btn-secondary btn-sm" onclick="togglePassword('${entry.uuid}', \`${escapeHtml(password)}\`)">üëÅÔ∏è Mostra</button>
                        <button class="btn-info btn-sm" onclick="copyToClipboard(\`${escapeHtml(username)}\`, 'Username')">üìã User</button>
                        <button class="btn-info btn-sm" onclick="copyToClipboard(\`${escapeHtml(password)}\`, 'Password')">üìã Pass</button>
                        <button class="btn-primary btn-sm" onclick="editEntry('${entry.uuid}')">‚úèÔ∏è Modifica</button>
                        <button class="btn-danger btn-sm" onclick="deleteEntry('${entry.uuid}')">üóëÔ∏è Elimina</button>
                    </div>
                </div>
            `;
        }

        function renderEntries() {
            if (selectedEntryId) {
                renderEntryDetail(selectedEntryId);
                return;
            }

            const container = document.getElementById('entriesList');
            const group = selectedFolderId ? findGroupById(vaultData.root, selectedFolderId) : vaultData.root;
            
            let entries = group ? group.entries : [];
            
            if (searchQuery) {
                entries = searchAllEntries(vaultData.root, searchQuery);
            }
            
            if (entries.length === 0) {
                container.innerHTML = `
                    <div class="empty-state">
                        <svg fill="currentColor" viewBox="0 0 20 20">
                            <path d="M10 2a5 5 0 00-5 5v2a2 2 0 00-2 2v5a2 2 0 002 2h10a2 2 0 002-2v-5a2 2 0 00-2-2H7V7a3 3 0 015.905-.75 1 1 0 001.937-.5A5.002 5.002 0 0010 2z"/>
                        </svg>
                        <h3>Nessuna entry</h3>
                        <p>Aggiungi la tua prima password</p>
                    </div>
                `;
                return;
            }
            
            container.innerHTML = entries.map(entry => {
                const title = entry.strings.Title?.value || 'Untitled';
                const username = entry.strings.UserName?.value || '';
                const password = entry.strings.Password?.value || '';
                const url = entry.strings.URL?.value || '';
                
                return `
                    <div class="entry-item" onclick="selectEntry('${entry.uuid}')" style="cursor: pointer;">
                        <div class="entry-header">
                            <div class="entry-title">üîë ${escapeHtml(title)}</div>
                        </div>
                        
                        <div class="entry-details">
                            <span class="entry-label">Username:</span>
                            <span class="entry-value">${escapeHtml(username)}</span>
                            
                            ${url ? `
                                <span class="entry-label">URL:</span>
                                <span class="entry-value">${escapeHtml(url)}</span>
                            ` : ''}
                        </div>
                        
                        <div class="button-group">
                            <button class="btn-info btn-sm" onclick="event.stopPropagation(); copyToClipboard(\`${escapeHtml(password)}\`, 'Password')">üìã Password</button>
                            <button class="btn-primary btn-sm" onclick="event.stopPropagation(); editEntry('${entry.uuid}')">‚úèÔ∏è</button>
                            <button class="btn-danger btn-sm" onclick="event.stopPropagation(); deleteEntry('${entry.uuid}')">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function searchAllEntries(group, query) {
            let results = [];
            const q = query.toLowerCase();

            group.entries.forEach(entry => {
                const title = (entry.strings.Title?.value || '').toLowerCase();
                const username = (entry.strings.UserName?.value || '').toLowerCase();
                const url = (entry.strings.URL?.value || '').toLowerCase();
                
                if (title.includes(q) || username.includes(q) || url.includes(q)) {
                    results.push(entry);
                }
            });

            group.groups.forEach(subGroup => {
                results = results.concat(searchAllEntries(subGroup, query));
            });

            return results;
        }

        function filterEntries(query) {
            searchQuery = query.trim();
            selectedEntryId = null;
            renderFolderTree();
            renderEntries();
        }

        function togglePassword(id, password) {
            const element = document.getElementById('pwd-' + id);
            const button = event.target;
            
            if (element.classList.contains('password-hidden')) {
                element.classList.remove('password-hidden');
                element.textContent = password;
                button.textContent = 'üôà Nascondi';
            } else {
                element.classList.add('password-hidden');
                element.textContent = '‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢';
                button.textContent = 'üëÅÔ∏è Mostra';
            }
        }

        function generatePassword() {
            const password = generateSecurePassword();
            showNotification(`üé≤ Password: ${password}`);
            copyToClipboard(password, 'Password');
        }

        function generatePasswordForEntry() {
            const password = generateSecurePassword();
            document.getElementById('entryPassword').value = password;
            checkPasswordStrength(password, 'entryStrengthBar');
        }

        function generateSecurePassword(length = 20) {
            const charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+-=[]{}|;:,.<>?";
            let password = "";
            
            password += "abcdefghijklmnopqrstuvwxyz"[Math.floor(Math.random() * 26)];
            password += "ABCDEFGHIJKLMNOPQRSTUVWXYZ"[Math.floor(Math.random() * 26)];
            password += "0123456789"[Math.floor(Math.random() * 10)];
            password += "!@#$%^&*()_+-="[Math.floor(Math.random() * 14)];
            
            for (let i = password.length; i < length; i++) {
                password += charset[Math.floor(Math.random() * charset.length)];
            }
            
            return password.split('').sort(() => Math.random() - 0.5).join('');
        }

        function checkPasswordStrength(password, barId) {
            const bar = document.getElementById(barId);
            if (!bar) return;
            
            if (!password) {
                bar.className = 'strength-bar';
                return;
            }
            
            let strength = 0;
            if (password.length >= 8) strength++;
            if (password.length >= 12) strength++;
            if (/[a-z]/.test(password) && /[A-Z]/.test(password)) strength++;
            if (/\d/.test(password)) strength++;
            if (/[^a-zA-Z0-9]/.test(password)) strength++;
            
            if (strength <= 2) {
                bar.className = 'strength-bar strength-weak';
            } else if (strength <= 4) {
                bar.className = 'strength-bar strength-medium';
            } else {
                bar.className = 'strength-bar strength-strong';
            }
        }

        function copyToClipboard(text, type) {
            navigator.clipboard.writeText(text).then(() => {
                showNotification(`üìã ${type} copiato`);
            });
        }

        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = 'notification';
            notification.textContent = message;
            
            if (type === 'error') {
                notification.style.background = '#dc3545';
            }
            
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.style.animation = 'slideIn 0.3s ease reverse';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        function escapeHtml(text) {
            if (!text) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
    </script>
</body>
</html>







